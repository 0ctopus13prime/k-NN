#ifndef KNNPLUGIN_JNI_FAISS_BBQ_FLAT_H
#define KNNPLUGIN_JNI_FAISS_BBQ_FLAT_H

#include "faiss/Index.h"
#include "faiss/MetricType.h"

#include <cstdint>
#include <stdexcept>
#include <iostream>

struct BBQDistanceComputer final : faiss::DistanceComputer {
    const int64_t oneElementByteSize;
    const uint64_t quantizedVectorBytes;
    const uint8_t* data;
    const uint8_t* query;
    const float centroidDp;
    float ay;
    float ly;
    float queryAdditional;
    float y1;
    int32_t dimension;
    int32_t numVectors;

    BBQDistanceComputer(int32_t _oneElementByteSize, const void* _data, float _centroidDp, int32_t _dimension, int32_t _numVectors)
      : faiss::DistanceComputer(),
        oneElementByteSize(_oneElementByteSize),
        quantizedVectorBytes(_oneElementByteSize - (sizeof(float) * 3 - sizeof(int32_t))),
        data((const uint8_t*) _data),
        query(),
        centroidDp(_centroidDp),
        dimension(_dimension),
        numVectors(_numVectors) {
    }

    void set_query(const float* x) final {
        query = (uint8_t*) x;
        if (uint64_t(query) >= uint64_t(data + numVectors * oneElementByteSize)) {
            std::cout << "_____________ query=" << uint64_t(query)
                      << ", data=" << uint64_t(data)
                      << ", end=" << uint64_t(data + numVectors * oneElementByteSize)
                      << std::endl;
            std::cout << "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" << std::endl;
            throw std::runtime_error("Query address is out of range.");
        }
        setCorrectionFactors(query, ay, ly, queryAdditional, y1);
    }

    void setCorrectionFactors(const void* target, float& lowerInterval, float& intervalLength, float& additionalCorrection, float& quantizedComponentSum) {
        // [Quantized Vector | lowerInterval (float) | upperInterval (float) | additionalCorrection (float) | quantizedComponentSum (int)]
        const auto* correctionFactors = (const float*) ((const uint8_t*) target + quantizedVectorBytes);
        lowerInterval = correctionFactors[0];
        intervalLength = correctionFactors[1] - correctionFactors[0];
        additionalCorrection = correctionFactors[2];
        quantizedComponentSum = *((const int32_t*) (&correctionFactors[3]));
//        std::cout << "_____________ lowerInterval->" << lowerInterval
//                  << ", intervalLength->" << intervalLength
//                  << ", additionalCorrection->" << additionalCorrection
//                  << ", quantizedComponentSum->" << quantizedComponentSum
//                  << std::endl;
    }

    float scoringSecondPart(const void* target, const float hamming) {
        // Get correction factors
        float ax;
        float lx;
        float additional;
        float x1;
        setCorrectionFactors(target, ax, lx, additional, x1);

        // Scoring
        return ax * ay * dimension
               + ay * lx * x1
               + ax * ly * y1
               + lx * ly * hamming
               + queryAdditional
               + additional
               - centroidDp;
    }

    /// compute distance of vector i to current query
    float operator()(faiss::idx_t i) final {
        const uint64_t* target = reinterpret_cast<const uint64_t*>(data + i * oneElementByteSize);

        const uint64_t words = quantizedVectorBytes >> 3; // divide by 8

        uint32_t hamming = 0;

        for (size_t i = 0; i < words; ++i) {
            hamming += __builtin_popcountll(query[i] ^ target[i]);
        }

        return scoringSecondPart(target, hamming);
    }

    /// compute distances of current query to 4 stored vectors.
    /// certain DistanceComputer implementations may benefit
    /// heavily from this.
    void distances_batch_4(
            const faiss::idx_t idx0,
            const faiss::idx_t idx1,
            const faiss::idx_t idx2,
            const faiss::idx_t idx3,
            float& dis0,
            float& dis1,
            float& dis2,
            float& dis3) final {
        const uint64_t* target1 = reinterpret_cast<const uint64_t*>(data + idx0 * oneElementByteSize);
        const uint64_t* target2 = reinterpret_cast<const uint64_t*>(data + idx1 * oneElementByteSize);
        const uint64_t* target3 = reinterpret_cast<const uint64_t*>(data + idx2 * oneElementByteSize);
        const uint64_t* target4 = reinterpret_cast<const uint64_t*>(data + idx3 * oneElementByteSize);

        const uint64_t words = quantizedVectorBytes >> 3; // divide by 8

        uint32_t hamming1 = 0;
        uint32_t hamming2 = 0;
        uint32_t hamming3 = 0;
        uint32_t hamming4 = 0;

        for (size_t i = 0; i < words; ++i) {
            hamming1 += __builtin_popcountll(query[i] ^ target1[i]);
            hamming2 += __builtin_popcountll(query[i] ^ target2[i]);
            hamming3 += __builtin_popcountll(query[i] ^ target3[i]);
            hamming4 += __builtin_popcountll(query[i] ^ target4[i]);
        }

        dis0 = scoringSecondPart(target1, hamming1);
        dis1 = scoringSecondPart(target2, hamming2);
        dis2 = scoringSecondPart(target3, hamming3);
        dis3 = scoringSecondPart(target4, hamming4);
    }

    /// compute distance between two stored vectors
    float symmetric_dis(faiss::idx_t i, faiss::idx_t j) {
        const uint64_t* target1 = reinterpret_cast<const uint64_t*>(data + i * oneElementByteSize);
        const uint64_t* target2 = reinterpret_cast<const uint64_t*>(data + j * oneElementByteSize);

        const uint64_t words = quantizedVectorBytes >> 3; // divide by 8

        uint32_t hamming = 0;

        for (size_t i = 0; i < words; ++i) {
            hamming += __builtin_popcountll(target1[i] ^ target2[i]);
        }

        // Get correction factors
        float ax;
        float lx;
        float additional;
        float x1;
        setCorrectionFactors(target1, ax, lx, additional, x1);

        float az;
        float lz;
        float additionalz;
        float z1;
        setCorrectionFactors(target2, az, lz, additionalz, z1);

        // Scoring
        return ax * az * dimension
               + az * lx * x1
               + ax * lz * z1
               + lx * lz * hamming
               + additional
               + additionalz
               - centroidDp;
    }
};

struct FaissBBQFlat final : public faiss::Index {
    int64_t numVectors;
    int32_t quantizedVectorBytes;
    float centroidDp;
    int32_t oneElementSize;
    std::vector<uint8_t> quantizedVectorsAndCorrectionFactors;
    int32_t dimension;

    FaissBBQFlat(int64_t _numVectors, int32_t _quantizedVectorBytes, float _centroidDp, int32_t _dimension)
        : faiss::Index(_dimension, faiss::MetricType::METRIC_INNER_PRODUCT),
          numVectors(_numVectors),
          quantizedVectorBytes(_quantizedVectorBytes),
          centroidDp(_centroidDp),
          oneElementSize(_quantizedVectorBytes + 3 * sizeof(float) + sizeof(int32_t)),
          quantizedVectorsAndCorrectionFactors(_numVectors * oneElementSize),
          dimension(_dimension) {

        quantizedVectorsAndCorrectionFactors.resize(0);
    }

    faiss::DistanceComputer* get_distance_computer() const final {
        std::cout << "___________ FaissBBQFlat::get_distance_computer(), quantizedVectorsAndCorrectionFactors.size()="
                  << quantizedVectorsAndCorrectionFactors.size()
                  << std::endl;
        return new BBQDistanceComputer(oneElementSize, quantizedVectorsAndCorrectionFactors.data(), centroidDp, dimension, numVectors);
    }

    void reset() final {
        throw std::runtime_error("FaissBBQFlat::reset() not implemented.");
    }

    void search(
            faiss::idx_t n,
            const float* x,
            faiss::idx_t k,
            float* distances,
            faiss::idx_t* labels,
            const faiss::SearchParameters* params = nullptr) const final {
        // No-op
        throw std::runtime_error("FaissBBQFlat::search() not implemented.");
    }

    void add(faiss::idx_t n, const float* x) final {
        ntotal += n;
    }
};

#endif //KNNPLUGIN_JNI_FAISS_BBQ_FLAT_H
